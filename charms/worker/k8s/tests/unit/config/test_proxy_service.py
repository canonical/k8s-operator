# Copyright 2025 Canonical Ltd.
# See LICENSE file for licensing details.

# Learn more about testing at: https://juju.is/docs/sdk/testing

"""Unit tests for config.proxy_service."""

import os
from pathlib import Path
from unittest import mock

import config.proxy_service
import literals
import ops.testing
import pytest
from charm import K8sCharm

import charms.contextual_status as status

PROXY_EXAMPLE_COM = "https://proxy.example.com:8080"
NO_PROXY = "127.0.0.1,localhost.::1,example.com"


@pytest.fixture(params=["worker", "control-plane"])
def harness(request):
    """Craft a ops test harness.

    Args:
        request: pytest request object
    """
    meta = Path(__file__).parent / "../../../charmcraft.yaml"
    if request.param == "worker":
        meta = Path(__file__).parent / "../../../../charmcraft.yaml"
    harness = ops.testing.Harness(K8sCharm, meta=meta.read_text())
    harness.disable_hooks()
    harness.begin()
    harness.charm.is_worker = request.param == "worker"
    yield harness
    harness.cleanup()


@pytest.fixture(autouse=True)
def mock_getenv(harness):
    """Mock environment variables."""

    def wrapped(name, default=None):
        """Return a mock value for environment variables."""
        if name.upper() == "JUJU_UNIT_NAME":
            return harness.charm.unit.name
        elif name.upper().endswith("HTTPS_PROXY"):
            return PROXY_EXAMPLE_COM
        elif name.upper().endswith("HTTP_PROXY"):
            return PROXY_EXAMPLE_COM
        elif name.upper().endswith("NO_PROXY"):
            return NO_PROXY
        if value := os.environ.get(name):
            return value
        return default

    with mock.patch("os.getenv") as getenv:
        getenv.side_effect = wrapped
        yield getenv


@mock.patch("charms.proxylib.environ")
def test_invalid_url_blocks(environ, harness):
    """Test that the proxy service config handles valid services."""
    harness.update_config({literals.WEB_PROXY_ENABLE_CONTAINERD.name: True})
    environ.return_value.error = "invalid url"
    with pytest.raises(status.ReconcilerError):
        config.proxy_service.apply(harness.charm)


@mock.patch("pathlib.Path.write_text")
@mock.patch("pathlib.Path.read_text")
@mock.patch("pathlib.Path.exists")
@mock.patch("pathlib.Path.mkdir")
@mock.patch.object(config.proxy_service, "systemd")
def test_enable_containerd_proxy(systemd, mkdir, exists, read_text, write_text, harness):
    """Test that the proxy service config handles valid services."""
    juju_app = harness.charm.app.name
    service = config.proxy_service.CONTAINERD_SERVICE_NAME
    harness.update_config({literals.WEB_PROXY_ENABLE_CONTAINERD.name: True})
    exists.return_value = True
    read_text.return_value = "replace me"
    expected = (
        "[Service]\n"
        f"# Autogenerated by {juju_app=} for {service=}\n"
        f'Environment="http_proxy={PROXY_EXAMPLE_COM}"\n'
        f'Environment="HTTP_PROXY={PROXY_EXAMPLE_COM}"\n'
        f'Environment="https_proxy={PROXY_EXAMPLE_COM}"\n'
        f'Environment="HTTPS_PROXY={PROXY_EXAMPLE_COM}"\n'
        f'Environment="no_proxy={NO_PROXY}"\n'
        f'Environment="NO_PROXY={NO_PROXY}"\n'
    )

    config.proxy_service.apply(harness.charm)

    mkdir.assert_called_once_with(parents=True, exist_ok=True)
    exists.assert_called_once_with()
    write_text.assert_called_once_with(expected, encoding="utf-8")
    systemd.daemon_reload.assert_called_once_with()
    systemd.service_running.assert_called_once_with(service)
    systemd.service_restart.assert_called_once_with(service)

    # Confirm no changes don't trigger a reload or restart
    mkdir.reset_mock()
    exists.reset_mock()
    write_text.reset_mock()
    systemd.daemon_reload.reset_mock()
    systemd.service_running.reset_mock()
    systemd.service_restart.reset_mock()
    read_text.return_value = expected

    config.proxy_service.apply(harness.charm)

    mkdir.assert_called_once_with(parents=True, exist_ok=True)
    exists.assert_called_once_with()
    write_text.assert_not_called()
    systemd.daemon_reload.assert_not_called()
    systemd.service_running.assert_not_called()
    systemd.service_restart.assert_not_called()


@mock.patch("pathlib.Path.write_text")
@mock.patch("pathlib.Path.read_text")
@mock.patch("pathlib.Path.exists")
@mock.patch("pathlib.Path.mkdir")
@mock.patch.object(config.proxy_service, "systemd")
def test_disable_containerd_proxy(systemd, mkdir, exists, read_text, write_text, harness):
    """Test that the proxy service config handles valid services."""
    service = config.proxy_service.CONTAINERD_SERVICE_NAME
    harness.update_config({literals.WEB_PROXY_ENABLE_CONTAINERD.name: False})
    exists.return_value = True
    read_text.return_value = "replace me"

    config.proxy_service.apply(harness.charm)

    mkdir.assert_called_once_with(parents=True, exist_ok=True)
    exists.assert_called_once_with()
    write_text.assert_called_once_with("", encoding="utf-8")
    systemd.daemon_reload.assert_called_once_with()
    systemd.service_running.assert_called_once_with(service)
    systemd.service_restart.assert_called_once_with(service)
