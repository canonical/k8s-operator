# Copyright 2025 Canonical Ltd.
# See LICENSE file for licensing details.

"""K8s Certificates module."""

import ipaddress
import logging
from typing import Dict, List, Optional, Protocol, Set, Tuple, Union

import ops
from literals import (
    CLUSTER_CERTIFICATES_KEY,
    CLUSTER_RELATION,
    CONTROL_PLANE_CERTIFICATES,
    SUPPORTED_CERTIFICATES,
    WORKER_CERTIFICATES,
)
from protocols import K8sCharmProtocol

import charms.contextual_status as status
from charms.k8s.v0.k8sd_api_manager import (
    BootstrapConfig,
    ControlPlaneNodeJoinConfig,
    NodeJoinConfig,
)
from charms.tls_certificates_interface.v4.tls_certificates import (
    CertificateRequestAttributes,
    Mode,
    PrivateKey,
    ProviderCertificate,
    TLSCertificatesRequiresV4,
)

log = logging.getLogger(__name__)


class CertificateProvider(Protocol):
    """Protocol defining the interface for certificate providers."""

    on: ops.CharmEvents

    @property
    def events(self) -> List[ops.CharmEvents]:
        """Return the events that the provider emits."""
        ...

    def get_assigned_certificate(
        self, request: CertificateRequestAttributes
    ) -> Tuple[ProviderCertificate, PrivateKey]:
        """Get a certificate/key pair for the given request."""
        ...


class NoOpCertificateProvider:
    """No-Op certificate provider for when external certificates are not in use."""

    on = ops.CharmEvents()

    @property
    def events(self) -> List[ops.CharmEvents]:
        """Return an empty list of events."""
        return []

    def get_assigned_certificate(
        self, request: CertificateRequestAttributes
    ) -> Tuple[ProviderCertificate, PrivateKey]:
        """Raise an error as this method should never be called."""
        # NOTE: This should never be called as the self-signed certificates will be
        # generated by the snap.
        raise status.ReconcilerError(
            f"No certificate provider available for {request.common_name}"
        )


class RefreshCertificates(ops.EventBase):
    """Event emitted when the certificates need to be refreshed."""


class K8sCertificates(ops.Object):
    """A class for managing Kubernetes certificates associated with a cluster unit.

    Attributes:
        events (List[str]): A list of events emitted by the Certificates library.
        using_external_certificates (bool): Whether the charm is using external certificates.
    """

    def __init__(self, charm: K8sCharmProtocol, refresh_event: ops.EventSource) -> None:
        """Initialize the K8sCertificates class.

        Args:
            charm: An instance of the charm.
            refresh_event: An event source that triggers certificate refresh.
        """
        super().__init__(charm, "certificates-integration")
        self._charm = charm
        self.certificates = self._init_certificates_provider(refresh_event)
        self.refresh_event = refresh_event

    def _init_certificates_provider(self, refresh_event: ops.EventSource) -> CertificateProvider:
        """Return a certificate provider based on the charm configuration.

        Args:
            refresh_event: An event source that triggers certificate refresh.

        Returns:
            CertificateProvider: An instance implementing the CertificateProvider protocol.
        """
        if self._get_certificates_provider() == "external":
            return TLSCertificatesRequiresV4(
                charm=self._charm,
                relationship_name="certificates",
                certificate_requests=self._certificate_requests,
                mode=Mode.UNIT,
                refresh_events=[refresh_event],
            )
        return NoOpCertificateProvider()

    @property
    def using_external_certificates(self) -> bool:
        """Return whether the charm is using external certificates."""
        return self._get_certificates_provider() == "external"

    @property
    def events(self) -> List[ops.CharmEvents]:
        """Return the events that the Certificates library emits."""
        return (
            [self.certificates.on.certificate_available]
            if self.using_external_certificates
            else []
        )

    @property
    def _certificate_requests(self) -> List[CertificateRequestAttributes]:
        """Generate certificates requests for all supported components."""
        return list(self._certificates_request_mapping.values())

    @property
    def _certificates_request_mapping(
        self,
    ) -> Dict[str, CertificateRequestAttributes]:
        node_name = self._charm.get_node_name()
        sans_ip = {"127.0.0.1", "::1"}
        sans_dns = {
            node_name,
            "kubernetes",
            "kubernetes.default",
            "kubernetes.default.svc",
            "kubernetes.default.svc.cluster.local",
        }

        if self._charm.is_control_plane:
            sans_ip.update(self._get_service_ips())

        extra_ips, extra_dns = self._charm.split_sans_by_type()
        sans_ip.update(extra_ips)
        sans_dns.update(extra_dns)

        csr_attributes = {
            "admin": CertificateRequestAttributes(
                common_name="kubernetes:admin",
                organization="system:masters",
            ),
            "controller": CertificateRequestAttributes(
                common_name="system:kube-controller-manager",
            ),
            "scheduler": CertificateRequestAttributes(
                common_name="system:kube-scheduler",
            ),
            "proxy": CertificateRequestAttributes(
                common_name="system:kube-proxy",
            ),
            "apiserver": CertificateRequestAttributes(
                common_name="kube-apiserver",
                sans_dns=frozenset(sans_dns),
                sans_ip=frozenset(sans_ip),
            ),
            "front-proxy-client": CertificateRequestAttributes(
                common_name="front-proxy-client",
            ),
            "kubelet": CertificateRequestAttributes(
                common_name=f"system:node:{node_name}",
                organization="system:nodes",
                sans_dns=frozenset(sans_dns),
                sans_ip=frozenset(sans_ip),
            ),
            "kubelet-client": CertificateRequestAttributes(
                common_name=f"system:node:{node_name}",
                organization="system:nodes",
            ),
            "apiserver-kubelet-client": CertificateRequestAttributes(
                common_name=f"system:node:{node_name}",
                organization="system:nodes",
            ),
        }

        if self._charm.lead_control_plane:
            return csr_attributes
        if self._charm.is_control_plane:
            return {k: v for k, v in csr_attributes.items() if k in CONTROL_PLANE_CERTIFICATES}
        return {k: v for k, v in csr_attributes.items() if k in WORKER_CERTIFICATES}

    def _get_service_ips(self) -> Set[str]:
        """Get Kubernetes service IPs from the CIDRs.

        Returns:
            Set[str]: A set of Kubernetes service IPs.

        Raises:
            ValueError: If the service CIDR is invalid.
        """
        service_ips = set()
        service_cidrs = self._charm.config.get("bootstrap-service-cidr", "").split(",")
        for cidr in service_cidrs:
            cidr = cidr.strip()
            try:
                network = ipaddress.ip_network(cidr)
                service_ips.add(str(network[1]))
            except ValueError:
                log.exception("Invalid service CIDR: %s", cidr)
                raise
        return service_ips

    def _get_validated_certificate(
        self, request: CertificateRequestAttributes
    ) -> Tuple[ProviderCertificate, PrivateKey]:
        """Get and validate a certificate/key pair for the given request.

        Args:
            request (CertificateRequestAttributes): The certificate request attributes.

        Returns:
            Tuple[ProviderCertificate, PrivateKey]: A tuple containing the certificate and key.

        Raises:
            ReconcilerError: If the certificate/key pair is missing.
        """
        certificate, key = self.certificates.get_assigned_certificate(request)
        if not certificate or not key:
            self.refresh_event.emit()
            raise status.ReconcilerError(f"Missing certificate/key pair for {request.common_name}")

        return certificate, key

    def _populate_join_certificates(self, config: NodeJoinConfig) -> None:
        """Configure the provided NodeJoinConfig certificates.

        Args:
            config (NodeJoinConfig): An instance of NodeJoinConfig where the
                certificates and keys will be stored.
        """
        attrs = self._certificates_request_mapping

        if isinstance(config, ControlPlaneNodeJoinConfig):
            certificate, key = self._get_validated_certificate(attrs["apiserver"])
            config.apiserver_crt = str(certificate.certificate)
            config.apiserver_key = str(key)

            certificate, key = self._get_validated_certificate(attrs["front-proxy-client"])
            config.front_proxy_client_crt = str(certificate.certificate)
            config.front_proxy_client_key = str(key)

            certificate, key = self._get_validated_certificate(attrs["admin"])
            config.admin_client_cert = str(certificate.certificate)
            config.admin_client_key = str(key)

            certificate, key = self._get_validated_certificate(attrs["scheduler"])
            config.kube_scheduler_client_cert = str(certificate.certificate)
            config.kube_scheduler_client_key = str(key)

            certificate, key = self._get_validated_certificate(attrs["controller"])
            config.kube_controller_manager_client_cert = str(certificate.certificate)
            config.kube_controller_manager_client_key = str(key)

        certificate, key = self._get_validated_certificate(attrs["kubelet"])
        config.kubelet_cert = str(certificate.certificate)
        config.kubelet_key = str(key)

        certificate, key = self._get_validated_certificate(attrs["kubelet-client"])
        config.kubelet_client_cert = str(certificate.certificate)
        config.kubelet_client_key = str(key)

        certificate, key = self._get_validated_certificate(attrs["proxy"])
        config.kube_proxy_client_cert = str(certificate.certificate)
        config.kube_proxy_client_key = str(key)

    def _populate_bootstrap_certificates(self, bootstrap_config: BootstrapConfig) -> None:
        """Configure the provided BootstrapConfig certificates.

        Args:
            bootstrap_config (BootstrapConfig): An instance of BootstrapConfig
                where the certificates and keys will be stored.
        """
        attrs = self._certificates_request_mapping

        certificate, key = self._get_validated_certificate(attrs["apiserver"])
        bootstrap_config.ca_cert = str(certificate.ca)
        bootstrap_config.client_ca_cert = str(certificate.ca)
        bootstrap_config.api_server_cert = str(certificate.certificate)
        bootstrap_config.api_server_key = str(key)

        certificate, key = self._get_validated_certificate(attrs["front-proxy-client"])
        bootstrap_config.front_proxy_ca_cert = str(certificate.ca)
        bootstrap_config.front_proxy_client_cert = str(certificate.certificate)
        bootstrap_config.front_proxy_client_key = str(key)

        certificate, key = self._get_validated_certificate(attrs["kubelet"])
        bootstrap_config.kubelet_cert = str(certificate.certificate)
        bootstrap_config.kubelet_key = str(key)

        certificate, key = self._get_validated_certificate(attrs["kubelet-client"])
        bootstrap_config.kubelet_client_cert = str(certificate.certificate)
        bootstrap_config.kubelet_client_key = str(key)

        certificate, key = self._get_validated_certificate(attrs["apiserver-kubelet-client"])
        bootstrap_config.api_server_kubelet_client_cert = str(certificate.certificate)
        bootstrap_config.api_server_kubelet_client_key = str(key)

        certificate, key = self._get_validated_certificate(attrs["admin"])
        bootstrap_config.admin_client_cert = str(certificate.certificate)
        bootstrap_config.admin_client_key = str(key)

        certificate, key = self._get_validated_certificate(attrs["controller"])
        bootstrap_config.kube_controller_manager_client_cert = str(certificate.certificate)
        bootstrap_config.kube_controller_manager_client_key = str(key)

        certificate, key = self._get_validated_certificate(attrs["scheduler"])
        bootstrap_config.kube_scheduler_client_cert = str(certificate.certificate)
        bootstrap_config.kube_scheduler_client_key = str(key)

        certificate, key = self._get_validated_certificate(attrs["proxy"])
        bootstrap_config.kube_proxy_client_cert = str(certificate.certificate)
        bootstrap_config.kube_proxy_client_key = str(key)

    def _get_certificates_provider(self) -> Optional[str]:
        """Get the certificates provider.

        Returns:
            str: The certificates provider.
        """
        if self._charm.is_control_plane:
            return str(self._charm.config.get("bootstrap-certificates"))

        # NOTE: This operation is safe because we're validating the provider during the
        # certificate configuration in the `configure_certificates` method.
        relation = self.model.get_relation(CLUSTER_RELATION)
        if not relation:
            return None

        if not (provider := relation.data[relation.app].get(CLUSTER_CERTIFICATES_KEY)):
            log.info("Waiting for certificates provider")
            return None

        return provider

    def configure_certificates(self, config: Union[BootstrapConfig, NodeJoinConfig]):
        """Configure the certificates for the Kubernetes cluster.

        Args:
            config (BootstrapConfig):
                The configuration object for the Kubernetes cluster. This object
                will be modified in-place to include the cluster's certificates.

        Raises:
            ReconcilerError: If the certificates issuer is invalid.
        """
        certificates_type = self._get_certificates_provider()

        if certificates_type not in SUPPORTED_CERTIFICATES:
            log.error(
                "Unsupported certificate issuer: %s. Valid options: %s",
                certificates_type,
                ", ".join(SUPPORTED_CERTIFICATES),
            )
            status.add(ops.BlockedStatus(f"Invalid certificates issuer: {certificates_type}"))
            raise status.ReconcilerError("Invalid certificates issuer")

        if certificates_type == "external":
            log.info("Using external certificates")
            certificates_relation = self._charm.model.get_relation("certificates")
            if not certificates_relation:
                msg = "Missing required 'certificates' relation"
                status.add(ops.BlockedStatus(msg))
                raise status.ReconcilerError(msg)

            if self._charm.lead_control_plane and isinstance(config, BootstrapConfig):
                self._populate_bootstrap_certificates(config)
            elif self._charm.is_control_plane and isinstance(config, ControlPlaneNodeJoinConfig):
                self._populate_join_certificates(config)
            elif isinstance(config, NodeJoinConfig):
                self._populate_join_certificates(config)
